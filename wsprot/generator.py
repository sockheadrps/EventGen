"""
Code generator for WebSocket protocol definitions.

Generates three files:
- models.py: Pydantic v2 models for each event payload
- events.py: @on_event decorator and dispatcher logic
- handlers.py: Handler base classes with event stubs
"""

import os
from pathlib import Path
from textwrap import dedent, indent

from .schema import Direction, Event, Field, Protocol


class ProtocolGenerator:
    """
    Generates Python code from a Protocol definition.

    Usage:
        protocol = Protocol.from_yaml_file("protocol.yaml")
        generator = ProtocolGenerator(protocol)
        generator.write_all("output/")
    """

    def __init__(
        self,
        protocol: Protocol,
        discriminator: str = "type",
    ):
        self.protocol = protocol
        self.discriminator = discriminator
        self._indent = "    "

    def _ind(self, code: str, level: int = 1) -> str:
        """Indent code by the specified level."""
        return indent(code, self._indent * level)

    # =========================================================================
    # models.py generation
    # =========================================================================

    def _generate_field(self, field: Field) -> str:
        """Generate a single Pydantic field definition."""
        py_type = field.python_type(self.protocol.types)

        # Build Field() arguments
        field_args = []

        if field.alias:
            field_args.append(f'alias="{field.alias}"')

        default_repr = field.default_repr()
        if default_repr is not None:
            field_args.append(f"default={default_repr}")

        if field.description:
            field_args.append(f'description="{field.description}"')

        # Generate the line
        if field_args:
            return f"{field.name}: {py_type} = Field({', '.join(field_args)})"
        elif default_repr is not None:
            return f"{field.name}: {py_type} = {default_repr}"
        else:
            return f"{field.name}: {py_type}"

    def _generate_enum(self, name: str, values: list[str]) -> str:
        """Generate a Python Enum class."""
        lines = [f"class {name}(str, Enum):"]
        for value in values:
            # Handle empty string or special chars if necessary, but assuming simple identifiers for now
            # Convert value to uppercase identifier: "in_combat" -> "IN_COMBAT"
            str_value = str(value)
            ident = str_value.upper().replace(" ", "_").replace("-", "_").replace(".", "_")
            if not ident.isidentifier():
                # Fallback or error - simplistic handling for now
                ident = f"VAL_{ident}"
            lines.append(self._ind(f'{ident} = "{str_value}"'))
        return "\n".join(lines)

    def _generate_model(self, event: Event) -> str:
        """Generate a Pydantic model for an event."""
        class_name = event.get_class_name()

        lines = [f"class {class_name}(BaseModel):"]

        if event.description:
            lines.append(self._ind(f'"""{event.description}"""'))

        # Discriminator field
        lines.append(
            self._ind(f'{self.discriminator}: Literal["{event.name}"] = "{event.name}"')
        )

        # Payload fields
        for field in event.fields:
            lines.append(self._ind(self._generate_field(field)))

        return "\n".join(lines)

    def generate_models(self) -> str:
        """Generate models.py content."""
        lines = [
            '"""',
            f"Pydantic models for {self.protocol.name} protocol.",
            "",
            "Auto-generated by wsprot. Do not edit.",
            '"""',
            "",
            "from __future__ import annotations",
            "",
            "from enum import Enum",
            "from typing import Annotated, Any, Literal",
            "",
            "from pydantic import BaseModel, Field",
            "",
            "",
            "# " + "=" * 70,
            "# Enums",
            "# " + "=" * 70,
        ]

        # Generate Enums
        for type_name, values in self.protocol.types.items():
            lines.append("")
            lines.append("")
            lines.append(self._generate_model_enum(f"{type_name}Enum", values))

        lines.extend([
            "",
            "",
        ])

        # Event Constants
        lines.extend([
            "# " + "=" * 70,
            "# Event Constants",
            "# " + "=" * 70,
        ])
        lines.append(self._generate_events_class())

        lines.extend([
            "",
            "",
            "# " + "=" * 70,
            "# Event Models",
            "# " + "=" * 70,
        ])

        for event in self.protocol.events:
            lines.append("")
            lines.append("")
            lines.append(self._generate_model(event))

        # Discriminated unions
        lines.extend(
            [
                "",
                "",
                "# " + "=" * 70,
                "# Discriminated Unions",
                "# " + "=" * 70,
            ]
        )

        c2s = self.protocol.client_to_server_events()
        s2c = self.protocol.server_to_client_events()

        if c2s:
            names = " | ".join(e.get_class_name() for e in c2s)
            lines.append("")
            lines.append(
                f'ClientMessage = Annotated[{names}, Field(discriminator="{self.discriminator}")]'
            )

        if s2c:
            names = " | ".join(e.get_class_name() for e in s2c)
            lines.append("")
            lines.append(
                f'ServerMessage = Annotated[{names}, Field(discriminator="{self.discriminator}")]'
            )

        return "\n".join(lines)

    def _generate_model_enum(self, name: str, values: list[str]) -> str:
        """Generate a Python Enum class (helper)."""
        return self._generate_enum(name, values)

    def _generate_events_class(self) -> str:
        """Generate the Events namespace class with nested features."""
        lines = ["class Events:"]
        
        # Group events by feature
        # Feature name -> list of events
        # None key for global events
        features: dict[str | None, list[Event]] = {}
        for event in self.protocol.events:
            feature = event.feature
            if feature not in features:
                features[feature] = []
            features[feature].append(event)
            
        # 1. Generate Global events (members of Events class directly)
        global_events = features.get(None, [])
        if global_events:
            for event in global_events:
                const_name = event.name.upper().replace(".", "_").replace("-", "_")
                lines.append(self._ind(f'{const_name} = "{event.name}"'))
        
        # 2. Generate Feature inner classes
        sorted_features = sorted([f for f in features.keys() if f is not None])
        for feature in sorted_features:
            class_name = feature.replace(" ", "").replace("-", "")  # e.g. "Chat"
            lines.append("")
            lines.append(self._ind(f"class {class_name}:"))
            for event in features[feature]:
                # For chat.join_room, we want just JOIN_ROOM inside Chat class
                # partial_name = event.name.removeprefix(feature.lower() + ".")
                # But safer to just split by dot if it exists, or use full name sanitizer
                if "." in event.name:
                    partial_name = event.name.split(".", 1)[1]
                else:
                    partial_name = event.name
                    
                const_name = partial_name.upper().replace(".", "_").replace("-", "_")
                lines.append(self._ind(f'{const_name} = "{event.name}"', 2))
                
        if len(lines) == 1:
            lines.append(self._ind("pass"))
            
        return "\n".join(lines)

    # =========================================================================
    # events.py generation
    # =========================================================================

    def generate_events(self) -> str:
        """Generate events.py content with decorator and dispatcher."""
        model_imports = ", ".join(e.get_class_name() for e in self.protocol.events)

        c2s = self.protocol.client_to_server_events()
        s2c = self.protocol.server_to_client_events()

        union_imports = []
        if c2s:
            union_imports.append("ClientMessage")
        if s2c:
            union_imports.append("ServerMessage")

        code = f'''\
"""
Event registration and dispatch for {self.protocol.name} protocol.

Auto-generated by wsprot. Do not edit.
"""

from __future__ import annotations

from typing import Any, Callable

from pydantic import TypeAdapter

from .models import {", ".join(union_imports)}


# Event type -> handler method name mapping
_handlers: dict[str, str] = {{}}


def on_event(event: str) -> Callable:
    """
    Decorator to register a method as handler for an event type.
    
    Usage:
        class MyHandler(BaseHandler):
            @on_event("join_room")
            async def handle_join(self, msg: JoinRoom) -> None:
                ...
    """
    def decorator(func: Callable) -> Callable:
        _handlers[event] = func.__name__
        return func
    return decorator


def get_handler_name(event: str) -> str | None:
    """Get the handler method name for an event type."""
    return _handlers.get(event)


def registered_events() -> list[str]:
    """Get all registered event types."""
    return list(_handlers.keys())
'''

        # Add dispatcher class for client messages
        if c2s:
            code += f'''

class ClientDispatcher:
    """
    Dispatcher for client->server messages.
    
    Usage:
        handler = MyHandler()
        dispatcher = ClientDispatcher(handler)
        
        async def on_message(data: str):
            await dispatcher(data)
    """
    
    _validator = TypeAdapter(ClientMessage)
    
    def __init__(self, handler: Any):
        self.handler = handler
    
    async def __call__(self, data: str | bytes | dict) -> Any:
        """Parse, validate, and dispatch a message."""
        if isinstance(data, dict):
            message = self._validator.validate_python(data)
        else:
            message = self._validator.validate_json(data)
        
        handler_name = _handlers.get(message.{self.discriminator})
        if handler_name is None:
            raise ValueError(f"No handler for event: {{message.{self.discriminator}}}")
        
        method = getattr(self.handler, handler_name)
        return await method(message)
'''

        # Add dispatcher class for server messages
        if s2c:
            code += f'''

class ServerDispatcher:
    """
    Dispatcher for server->client messages (for client-side handling).
    """
    
    _validator = TypeAdapter(ServerMessage)
    
    def __init__(self, handler: Any):
        self.handler = handler
    
    async def __call__(self, data: str | bytes | dict) -> Any:
        """Parse, validate, and dispatch a message."""
        if isinstance(data, dict):
            message = self._validator.validate_python(data)
        else:
            message = self._validator.validate_json(data)
        
        handler_name = _handlers.get(message.{self.discriminator})
        if handler_name is None:
            raise ValueError(f"No handler for event: {{message.{self.discriminator}}}")
        
        method = getattr(self.handler, handler_name)
        return await method(message)
'''

        return code

    # =========================================================================
    # handlers.py generation
    # =========================================================================

    def _generate_handler_method(self, event: Event) -> str:
        """Generate a handler method stub."""
        class_name = event.get_class_name()
        method_name = f"{event.name.replace('.', '_').replace('-', '_')}"

        # Determine the constant path (e.g. "Events.PING" or "Events.Chat.JOIN_ROOM")
        if event.feature:
            # Assumes feature class name matches feature name in protocol
            feature_cls = event.feature.replace(" ", "").replace("-", "")
            if "." in event.name:
                partial = event.name.split(".", 1)[1]
            else:
                partial = event.name
            const_name = partial.upper().replace(".", "_").replace("-", "_")
            decorator_arg = f"Events.{feature_cls}.{const_name}"
        else:
            const_name = event.name.upper().replace(".", "_").replace("-", "_")
            decorator_arg = f"Events.{const_name}"

        lines = [
            f'@on_event({decorator_arg})',
            f"async def {method_name}(self, message: {class_name}) -> Any:",
        ]

        if event.description:
            lines.append(self._ind(f'"""{event.description}"""'))

        lines.append(self._ind("raise NotImplementedError"))

        return "\n".join(lines)

    def _get_handler_groups(self, events: list[Event]) -> dict[str | None, list[Event]]:
        """Group events by handler_group."""
        groups: dict[str | None, list[Event]] = {}
        for event in events:
            group = event.handler_group
            if group not in groups:
                groups[group] = []
            groups[group].append(event)
        return groups

    def generate_handlers(self) -> str:
        """Generate handlers.py content."""
        c2s = self.protocol.client_to_server_events()
        s2c = self.protocol.server_to_client_events()

        # Collect model imports
        model_names = [e.get_class_name() for e in self.protocol.events]

        lines = [
            '"""',
            f"Handler stubs for {self.protocol.name} protocol.",
            "",
            "Implement your handler logic in the methods below.",
            "",
            "Generated by wsprot - edit this file freely!",
            '"""',
            "",
            "from __future__ import annotations",
            "",
            "from typing import Any",
            "",
            f"from .models import {', '.join(model_names)}, Events",
            "from .events import on_event",
        ]

        # Generate server-side handler (handles client messages)
        if c2s:
            groups = self._get_handler_groups(c2s)

            # Base handler with all events
            lines.extend(
                [
                    "",
                    "",
                    "# " + "=" * 70,
                    "# Server-side Handler (handles client->server messages)",
                    "# " + "=" * 70,
                ]
            )

            protocol_name = self.protocol.name.replace(" ", "").replace("-", "")

            # If there are groups, generate group-specific handlers first
            if None not in groups or len(groups) > 1:
                for group_name, group_events in groups.items():
                    if group_name is None:
                        continue

                    class_name = (
                        f"{protocol_name}{group_name.title().replace('_', '')}Handler"
                    )
                    lines.extend(
                        [
                            "",
                            "",
                            f"class {class_name}:",
                            self._ind(f'"""Handler for {group_name} events."""'),
                        ]
                    )

                    for event in group_events:
                        lines.append("")
                        lines.append(self._ind(self._generate_handler_method(event)))

            # Main handler (includes ungrouped + optionally inherits from groups)
            base_classes = []
            for group_name in groups:
                if group_name is not None:
                    base_classes.append(
                        f"{protocol_name}{group_name.title().replace('_', '')}Handler"
                    )

            base_str = f"({', '.join(base_classes)})" if base_classes else ""

            lines.extend(
                [
                    "",
                    "",
                    f"class {protocol_name}Handler{base_str}:",
                    self._ind(f'"""'),
                    self._ind(
                        f"Handler for {self.protocol.name} client->server messages."
                    ),
                    self._ind(f""),
                    self._ind(f"Implement the handler methods below."),
                    self._ind(f'"""'),
                ]
            )

            # Add ungrouped events to main handler
            ungrouped = groups.get(None, [])
            if ungrouped:
                for event in ungrouped:
                    lines.append("")
                    lines.append(self._ind(self._generate_handler_method(event)))
            elif not base_classes:
                lines.append(self._ind("pass"))

        # Generate client-side handler (handles server messages)
        if s2c:
            lines.extend(
                [
                    "",
                    "",
                    "# " + "=" * 70,
                    "# Client-side Handler (handles server->client messages)",
                    "# " + "=" * 70,
                ]
            )

            protocol_name = self.protocol.name.replace(" ", "").replace("-", "")

            lines.extend(
                [
                    "",
                    "",
                    f"class {protocol_name}ClientHandler:",
                    self._ind(f'"""'),
                    self._ind(
                        f"Handler for {self.protocol.name} server->client messages."
                    ),
                    self._ind(f'"""'),
                ]
            )

            for event in s2c:
                lines.append("")
                lines.append(self._ind(self._generate_handler_method(event)))

        return "\n".join(lines)

    # =========================================================================
    # __init__.py generation
    # =========================================================================

    def generate_init(self) -> str:
        """Generate __init__.py with exports."""
        c2s = self.protocol.client_to_server_events()
        s2c = self.protocol.server_to_client_events()

        model_names = [e.get_class_name() for e in self.protocol.events]
        protocol_name = self.protocol.name.replace(" ", "").replace("-", "")

        # Get handler group names
        groups = self._get_handler_groups(c2s) if c2s else {}
        group_handler_names = [
            f"{protocol_name}{g.title().replace('_', '')}Handler"
            for g in groups
            if g is not None
        ]

        exports = model_names.copy()

        if c2s:
            exports.append("ClientMessage")
        if s2c:
            exports.append("ServerMessage")

        exports.append("on_event")

        if c2s:
            exports.append("ClientDispatcher")
            exports.extend(group_handler_names)
            exports.append(f"{protocol_name}Handler")
        if s2c:
            exports.append("ServerDispatcher")
            exports.append(f"{protocol_name}ClientHandler")
        
        exports.append("Events")

        lines = [
            '"""',
            f"{self.protocol.name} protocol.",
            '"""',
            "",
            "from .models import (",
        ]

        for name in model_names:
            lines.append(f"    {name},")
        lines.append("    Events,")
        if c2s:
            lines.append("    ClientMessage,")
        if s2c:
            lines.append("    ServerMessage,")
        lines.append(")")

        lines.append("")
        lines.append("from .events import (")
        lines.append("    on_event,")
        if c2s:
            lines.append("    ClientDispatcher,")
        if s2c:
            lines.append("    ServerDispatcher,")
        lines.append(")")

        lines.append("")
        lines.append("from .handlers import (")
        for name in group_handler_names:
            lines.append(f"    {name},")
        if c2s:
            lines.append(f"    {protocol_name}Handler,")
        if s2c:
            lines.append(f"    {protocol_name}ClientHandler,")
        lines.append(")")

        lines.append("")
        lines.append("__all__ = [")
        for name in exports:
            lines.append(f'    "{name}",')
        lines.append("]")

        return "\n".join(lines)

    # =========================================================================
    # Split generation (server/ and client/ directories)
    # =========================================================================

    def _generate_side_models(self, events: list[Event], union_name: str, union_events: list[Event] = None) -> str:
        """Generate models.py for one side (client or server)."""
        if union_events is None:
            union_events = events

        lines = [
            '"""',
            f"Pydantic models for {self.protocol.name} protocol.",
            "",
            "Auto-generated by wsprot. Do not edit.",
            '"""',
            "",
            "from __future__ import annotations",
            "",
            "from typing import Annotated, Any, Literal",
            "",
            "from enum import Enum",
            "from pydantic import BaseModel, Field",
        ]

        # Generate Enums
        for type_name, values in self.protocol.types.items():
            lines.append("")
            lines.append("")
            lines.append(self._generate_model_enum(f"{type_name}Enum", values))

        for event in events:
            lines.append("")
            lines.append("")
            lines.append(self._generate_model(event))

        if union_events:
            names = " | ".join(e.get_class_name() for e in union_events)
            lines.append("")
            lines.append("")
            lines.append(
                f'{union_name} = Annotated[{names}, Field(discriminator="{self.discriminator}")]'
            )

        return "\n".join(lines)

    def _generate_side_events(self, union_name: str, dispatcher_name: str) -> str:
        """Generate events/__init__.py for one side."""
        return f'''\
"""
Event dispatch for {self.protocol.name} protocol.

Auto-generated by wsprot. Do not edit.
"""

from __future__ import annotations

from typing import Any, Callable

from pydantic import TypeAdapter

from ..models import {union_name}


_handlers: dict[str, str] = {{}}


def on_event(event: str) -> Callable:
    """Register a method as handler for an event type."""
    def decorator(func: Callable) -> Callable:
        _handlers[event] = func.__name__
        return func
    return decorator


class {dispatcher_name}:
    """Parse, validate, and dispatch messages."""
    
    _validator = TypeAdapter({union_name})
    
    def __init__(self, handler: Any):
        self.handler = handler
    
    async def __call__(self, data: str | bytes | dict) -> Any:
        if isinstance(data, dict):
            message = self._validator.validate_python(data)
        else:
            message = self._validator.validate_json(data)
        
        handler_name = _handlers.get(message.{self.discriminator})
        if handler_name is None:
            raise ValueError(f"No handler for event: {{message.{self.discriminator}}}")
        
        return await getattr(self.handler, handler_name)(message)


{self._generate_events_class()}
'''

    def _generate_side_handlers(self, events: list[Event], class_name: str) -> str:
        """Generate handlers/__init__.py for one side."""
        model_names = [e.get_class_name() for e in events]

        lines = [
            '"""',
            f"Handler base class for {self.protocol.name} protocol.",
            "",
            "Auto-generated by wsprot. Do not edit.",
            '"""',
            "",
            "from __future__ import annotations",
            "",
            "from typing import Any",
            "",
            f"from ..models import {', '.join(model_names)}",
            "from ..events import on_event, Events",
            "",
            "",
            f"class {class_name}:",
            self._ind('"""Subclass and override the handler methods."""'),
        ]

        for event in events:
            lines.append("")
            lines.append(self._ind(self._generate_handler_method(event)))

        return "\n".join(lines)

    def _generate_side_init(
        self, events: list[Event], union_name: str, handler_name: str, dispatcher_name: str
    ) -> str:
        """Generate top-level __init__.py for one side."""
        model_names = [e.get_class_name() for e in events]

        lines = [
            f"from .models import {', '.join(model_names)}, {union_name}",
            f"from .events import on_event, {dispatcher_name}, Events",
            f"from .handlers import {handler_name}",
            "",
            "__all__ = [",
        ]
        for name in model_names:
            lines.append(f'    "{name}",')
        lines.append(f'    "{union_name}",')
        lines.append('    "on_event",')
        lines.append(f'    "{dispatcher_name}",')
        lines.append(f'    "{handler_name}",')
        lines.append("]")

        return "\n".join(lines)

    # =========================================================================
    # JS Client generation
    # =========================================================================

    def _generate_js_client(self) -> str:
        """Generate a vanilla JavaScript client SDK."""
        c2s = self.protocol.client_to_server_events()
        s2c = self.protocol.server_to_client_events()
        
        protocol_name = self.protocol.name.replace(" ", "")
        class_name = f"{protocol_name}Client"
        
        lines = [
            f"/**",
            f" * {class_name} - Auto-generated by wsprot",
            f" * Protocol: {self.protocol.name} v{self.protocol.version}",
            f" */",
            "",
            # Generate Enums as JS Objects
        ]
        
        # Enums
        for type_name, values in self.protocol.types.items():
            lines.append(f"export const {type_name}Enum = {{")
            for value in values:
                # Value is string, we need to handle if it is numeric or logic? 
                # Schema says values are list of strings.
                # Key: UPPER_CASE, Value: actual value
                str_val = str(value)
                key = str_val.upper().replace(" ", "_").replace("-", "_").replace(".", "_")
                if not key.isidentifier():
                    key = f"VAL_{key}"
                lines.append(f"    {key}: '{str_val}',")
            lines.append(f"}};")
            lines.append("")

        lines.extend([
            f"export class {class_name} {{",
            f"    constructor(urlOrSocket) {{",
            f"        this.listeners = {{}};",
            f"        if (urlOrSocket) {{",
            f"            this.connect(urlOrSocket);",
            f"        }}",
            f"    }}",
            "",
            f"    connect(urlOrSocket) {{",
            f"        if (typeof urlOrSocket === 'string') {{",
            f"            this.socket = new WebSocket(urlOrSocket);",
            f"        }} else {{",
            f"            this.socket = urlOrSocket;",
            f"        }}",
            "",
            f"        console.log('[WSPROT] Connecting to', this.socket.url);",
            "",
            f"        this.socket.addEventListener('open', () => {{",
            f"            console.log('[WSPROT] WebSocket Connected');",
            f"        }});",
            "",
            f"        this.socket.addEventListener('close', (event) => {{",
            f"             console.log('[WSPROT] WebSocket Closed', event.code, event.reason);",
            f"        }});",
            "",
            f"        this.socket.addEventListener('error', (e) => {{",
            f"             console.error('[WSPROT] WebSocket Error', e);",
            f"        }});",
            "",
            f"        this.socket.addEventListener('message', (event) => {{",
            f"            try {{",
            f"                const data = JSON.parse(event.data);",
            f"                this._handleMessage(data);",
            f"            }} catch (e) {{",
            f"                console.error('Failed to parse incoming message', e);",
            f"            }}",
            f"        }});",
            f"    }}",
            "",
            f"    on(eventType, callback) {{",
            f"        if (!this.listeners[eventType]) {{",
            f"            this.listeners[eventType] = [];",
            f"        }}",
            f"        this.listeners[eventType].push(callback);",
            f"    }}",
            "",
            f"    _handleMessage(message) {{",
            f"        const handlers = this.listeners[message.{self.discriminator}];",
            f"        if (handlers) {{",
            f"            handlers.forEach(h => h(message));",
            f"        }}",
            f"    }}",
            ""
        ])
        
        # Generate send methods for client->server events
        if c2s:
            for event in c2s:
                method_name = f"send{event.get_class_name()}"
                
                # Build args list
                args = []
                payload_obj_props = []
                
                # Add docstring with params
                lines.append(f"    /**")
                lines.append(f"     * {event.description or 'Send ' + event.name}")
                
                for field in event.fields:
                    js_name = field.alias if field.alias else field.name
                    # Make camelCase for JS args convention? Or keep snake_case from python?
                    # The payload MUST match the Pydantic model expectations (aliases).
                    # Let's use the field name as argument name, but map to alias in payload.
                    
                    is_optional = not field.required
                    default_val = field.default
                    
                    arg_str = field.name
                    if is_optional and default_val is not None:
                        # Handle simple defaults for JS string
                         arg_str += f" = {repr(default_val)}"
                    
                    args.append(arg_str)
                    
                    # Construct property
                    payload_obj_props.append(f"{js_name}: {field.name}")
                    lines.append(f"     * @param {{{field.type}}} {field.name}")

                lines.append(f"     */")
                
                args_str = ", ".join(args)
                lines.append(f"    {method_name}({args_str}) {{")
                lines.append(f"        this.socket.send(JSON.stringify({{")
                lines.append(f"            {self.discriminator}: '{event.name}',")
                for prop in payload_obj_props:
                    lines.append(f"            {prop},")
                lines.append(f"        }}));")
                lines.append(f"    }}")
                lines.append("")

        lines.append(f"}}")
        lines.append(f"export {{ {class_name} as Client }};")
        return "\n".join(lines)

    def write_split(self, output_dir: str, integrate_webclient: bool = False, 
                   include_server: bool = True, include_client: bool = True, 
                   include_webclient: bool = True) -> None:
        """
        Write split files into server/ and client/ directories.
        
        Args:
            output_dir: Base output directory
            integrate_webclient: If True, put JS client in server/static/js/
            include_server: Whether to generate Python server code
            include_client: Whether to generate Python client code
            include_webclient: Whether to generate JS client code
        """
        base = Path(output_dir)
        base.mkdir(parents=True, exist_ok=True)

        protocol_name = self.protocol.name.replace(" ", "").replace("-", "")
        c2s = self.protocol.client_to_server_events()
        s2c = self.protocol.server_to_client_events()

        def write_pkg(base_dir: Path, name: str, content: str):
            pkg_dir = base_dir / name
            pkg_dir.mkdir(exist_ok=True)
            # Write content to explicit file (e.g. models/models.py)
            (pkg_dir / f"{name}.py").write_text(content)
            # Export from init
            (pkg_dir / "__init__.py").write_text(f"from .{name} import *")

        # Server side (handles client->server messages)
        server_dir = base / "server"
        if include_server and c2s:
            server_dir.mkdir(exist_ok=True)
            
            # Create subpackages
            write_pkg(server_dir, "models", self._generate_side_models(c2s + s2c, "ClientMessage", union_events=c2s))
            write_pkg(server_dir, "events", self._generate_side_events("ClientMessage", "ClientDispatcher"))
            write_pkg(server_dir, "handlers", self._generate_side_handlers(c2s, f"{protocol_name}Handler"))
            
            # Top level init
            (server_dir / "__init__.py").write_text(
                self._generate_side_init(
                    c2s + s2c, "ClientMessage", f"{protocol_name}Handler", "ClientDispatcher"
                )
            )
            print(f"  server/")

        # JS Client
        if include_webclient:
            # Common Application Logic (main.js)
            main_js_content = """import { Client } from './client.js';

const statusDiv = document.getElementById('status');
const messagesDiv = document.getElementById('messages');

// Calculate WebSocket URL
const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
const wsUrl = `${protocol}//${window.location.host}/ws`;

console.log('[App] Initializing Client for', wsUrl);

// Initialize Client
const client = new Client();

// UI Event Listeners
// We attach these before connecting so we don't miss events
// Note: client.socket is available because constructor creates it (if using new Client(url)) OR we create it manually?
// In our generated code: constructor(url) -> connect(url) -> sets this.socket.
// new Client() (empty) -> does NOT set this.socket.

// So we connect first? Or we use connect(url) which sets socket.
client.connect(wsUrl);

// Now client.socket is set
if (statusDiv && client.socket) {
    client.socket.addEventListener('open', () => {
        statusDiv.textContent = 'Connected';
    });
    client.socket.addEventListener('close', () => {
        statusDiv.textContent = 'Disconnected';
    });
}

if (messagesDiv && client.socket) {
    client.socket.addEventListener('message', (event) => {
        const div = document.createElement('div');
        div.textContent = `[Rx] ${event.data}`;
        messagesDiv.appendChild(div);
    });
}
"""

            index_html_template = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebSocket Client</title>
    <script src="{script_src}" type="module"></script>
</head>
<body>
    <h1>WebSocket Client</h1>
    <div id="status">Disconnected</div>
    <div id="messages"></div>
</body>
</html>"""

            # Determine location based on integration flag
            # Only integrate if server exists (or is being generated)
            use_integration = integrate_webclient and (include_server or server_dir.exists())
            
            if use_integration:
                js_out_dir = server_dir / "static" / "js"
                templates_dir = server_dir / "templates"
                
                js_out_dir.mkdir(parents=True, exist_ok=True)
                templates_dir.mkdir(exist_ok=True)
                
                # 1. SDK (client.js)
                (js_out_dir / "client.js").write_text(self._generate_js_client())
                
                # 2. App Logic (main.js)
                (js_out_dir / "main.js").write_text(main_js_content)
                
                # 3. HTML (index.html) importing /static/js/main.js
                (templates_dir / "index.html").write_text(index_html_template.format(script_src="/static/js/main.js"))
                
                print(f"  server/static/js/client.js")
                print(f"  server/static/js/main.js")
                print(f"  server/templates/index.html")
            else:
                webclient_dir = base / "webclient"
                webclient_dir.mkdir(exist_ok=True)
                
                # 1. SDK (client.js)
                (webclient_dir / "client.js").write_text(self._generate_js_client())
                
                # 2. App Logic (main.js)
                (webclient_dir / "main.js").write_text(main_js_content)
                
                # 3. HTML (index.html) importing ./main.js
                (webclient_dir / "index.html").write_text(index_html_template.format(script_src="./main.js"))
                
                print(f"  webclient/client.js")
                print(f"  webclient/main.js")
                print(f"  webclient/index.html")

        # Client side (handles server->client messages)
        # Only create if s2c events exist (Python client)
        if include_client and s2c:
            client_dir = base / "client"
            client_dir.mkdir(exist_ok=True)
            
            # Create subpackages
            # Pass all events so client can send (c2s) and receive (s2c)
            write_pkg(client_dir, "models", self._generate_side_models(s2c + c2s, "ServerMessage", union_events=s2c))
            write_pkg(client_dir, "events", self._generate_side_events("ServerMessage", "ServerDispatcher"))
            write_pkg(client_dir, "handlers", self._generate_side_handlers(s2c, f"{protocol_name}ClientHandler"))
            
            # Top level init
            (client_dir / "__init__.py").write_text(
                self._generate_side_init(
                    s2c + c2s, "ServerMessage", f"{protocol_name}ClientHandler", "ServerDispatcher"
                )
            )
            print(f"  client/")

    def write_all(self, output_dir: str, integrate_webclient: bool = False,
                 include_server: bool = True, include_client: bool = True, 
                 include_webclient: bool = True) -> None:
        """Alias for write_split, as we are adopting the split structure by default."""
        self.write_split(output_dir, integrate_webclient, include_server, include_client, include_webclient)
